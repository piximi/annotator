{"version":3,"sources":["reportWebVitals.ts","types/ToolType.ts","types/AnnotationModeType.ts","types/LanguageType.ts","images/cell-painting.png","store/slices/applicationSlice.ts","image/imageHelper.ts","store/slices/toolOptionsSlice.ts","types/ZoomModeType.ts","store/reducer/reducer.ts","store/stores/store.ts","store/thunks/echoThunk.ts","store/thunks/loadLayersModelThunk.ts","i18n.ts","translations/de.ts","translations/en.ts","translations/fi.ts","translations/hi.ts","translations/hu.ts","translations/se.ts","translations/gr.ts","index.tsx"],"names":["reportWebVitals","onPerfEntry","Function","then","_ref","getCLS","getFID","getFCP","getLCP","getTTFB","ToolType","AnnotationModeType","LanguageType","initialCategories","color","id","name","visible","initialState","annotated","annotating","boundingClientRect","DOMRect","brightness","categories","length","channels","range","currentIndex","cursor","contrast","exposure","hue","activeImageId","undefined","images","invertMode","language","English","offset","x","y","penSelectionBrushSize","pointerSelection","dragging","minimum","maximum","selecting","quickSelectionBrushSize","saturation","selectedAnnotation","selectedAnnotations","selectedCategory","selectionMode","New","soundEnabled","stageHeight","stageScale","stageWidth","stagePosition","toolType","RectangularAnnotation","vibrance","zoomSelection","applicationSlice","createSlice","reducers","addImages","state","action","_state$images","imageNames","map","image","split","updatedImages","payload","newImages","updatedName","names","currentName","i","includes","concat","replaceDuplicateName","_objectSpread","push","apply","_toConsumableArray","clearCategoryAnnotations","_step","_iterator","_createForOfIteratorHelper","s","n","done","value","annotations","filter","annotation","categoryId","category","err","e","f","deleteCategory","deleteImage","deleteAllInstances","deleteAllImageInstances","imageId","deleteImageInstances","updatedAnnotations","ids","openAnnotations","_state$images2","file","_importSerializedAnno","existingCategories","mask","annotationMask","parseInt","newCategories","annotationCategoryId","annotationCategoryColor","annotationCategoryName","annotation_out","boundingBox","annotationBoundingBoxX","annotationBoundingBoxY","annotationBoundingBoxWidth","annotationBoundingBoxHeight","annotationId","importSerializedAnnotations","loaded","avatar","imageData","src","originalSrc","imageFilename","shape","imageChannels","frames","imageFrames","height","imageHeight","planes","imagePlanes","width","imageWidth","setAnnotated","setAnnotating","setBoundingClientRect","setBrightness","setCategories","setCategoryVisibility","_","setContrast","setCurrentIndex","setExposure","setHue","setActiveImage","activeImage","find","defaultChannels","setImageInstances","instances","setImageSrc","setImages","setChannels","setCursor","setInvertMode","setLanguage","setOffset","setOperation","operation","setPenSelectionBrushSize","setPointerSelection","setQuickSelectionBrushSize","setSaturation","setSelectedCategory","setSelectedAnnotations","setSelectionMode","setStageHeight","setStagePosition","setStageScale","setStageWidth","setSoundEnabled","setVibrance","setZoomSelection","extraReducers","_defineProperty","console","info","_applicationSlice$act","actions","colorAdjustment","blackPoint","highlights","shadows","zoom","automaticCentering","mode","ZoomModeType","In","scale","toActualSize","toFit","toolOptionsSlice","setColorAdjustmentOptions","options","setZoomToolOptions","undoable","reducer","currentState","previousHistory","type","groupBy","groupByActionTypes","toolOptions","combineReducers","devTools","enhancers","Sentry","middleware","logger","thunk","preloadedState","store","configureStore","echo","_asyncToGenerator","_regeneratorRuntime","mark","_callee","message","wrap","_context","prev","next","abrupt","stop","_x","arguments","createAsyncThunk","_ref2","_callee2","_context2","sent","_x2","path","tensorflow","resources","de","translation","Cancel","Categories","Description","Edit","Help","Logo","Model","Open","Save","Settings","Unknown","en","fi","hi","hu","se","gr","interpolation","escapeValue","keySeparator","lng","i18n","use","initReactI18next","init","dsn","release","process","npm_package_version","Redirect","_jsxs","children","_jsx","href","ReactDOM","render","React","StrictMode","Provider","DndProvider","backend","HTML5Backend","document","getElementById"],"mappings":"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","file":"static/js/main.04de5166.chunk.js","sourcesContent":["import { ReportHandler } from \"web-vitals\";\n\nconst reportWebVitals = (onPerfEntry?: ReportHandler) => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import(\"web-vitals\").then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","export enum ToolType {\n  ColorAdjustment,\n  ColorAnnotation,\n  EllipticalAnnotation,\n  Hand,\n  LassoAnnotation,\n  MagneticAnnotation,\n  ObjectAnnotation,\n  PenAnnotation,\n  Pointer,\n  PolygonalAnnotation,\n  QuickAnnotation,\n  RectangularAnnotation,\n  Zoom,\n}\n","export enum AnnotationModeType {\n  Add,\n  Intersect,\n  New,\n  Subtract,\n}\n","export enum LanguageType {\n  Arabic,\n  English,\n  Farsi,\n  Finnish,\n  French,\n  German,\n  Greek,\n  Hindi,\n  Hungarian,\n  Spanish,\n}\n","export default __webpack_public_path__ + \"static/media/cell-painting.f118ef08.png\";","import { createSlice, PayloadAction } from \"@reduxjs/toolkit\";\nimport { CategoryType } from \"../../types/CategoryType\";\nimport { ImageType } from \"../../types/ImageType\";\nimport { ToolType } from \"../../types/ToolType\";\nimport { AnnotationType } from \"../../types/AnnotationType\";\nimport { AnnotationModeType } from \"../../types/AnnotationModeType\";\nimport * as _ from \"lodash\";\nimport colorImage from \"../../images/cell-painting.png\";\nimport { LanguageType } from \"../../types/LanguageType\";\nimport * as tensorflow from \"@tensorflow/tfjs\";\nimport { StateType } from \"../../types/StateType\";\nimport { SerializedAnnotationType } from \"../../types/SerializedAnnotationType\";\nimport { ChannelType } from \"../../types/ChannelType\";\nimport { SerializedFileType } from \"../../types/SerializedFileType\";\nimport {\n  importSerializedAnnotations,\n  replaceDuplicateName,\n} from \"../../image/imageHelper\";\n\nconst initialImage =\n  process.env.NODE_ENV === \"development\"\n    ? {\n        avatar: colorImage,\n        id: \"f8eecf66-8776-4e14-acd2-94b44603a1a7\",\n        annotations: [],\n        name: \"example.png\",\n        shape: {\n          channels: 3,\n          frames: 1,\n          height: 512,\n          planes: 1,\n          width: 512,\n        },\n        originalSrc: colorImage,\n        src: colorImage,\n      }\n    : undefined;\n\nconst initialCategories =\n  process.env.NODE_ENV === \"development\"\n    ? [\n        {\n          color: \"#AAAAAA\",\n          id: \"00000000-0000-0000-0000-000000000000\",\n          name: \"Unknown\",\n          visible: true,\n        },\n        {\n          color: \"#a08cd2\",\n          id: \"00000000-0000-0000-0000-000000000001\",\n          name: \"Cell membrane\",\n          visible: true,\n        },\n        {\n          color: \"#b8ddf3\",\n          id: \"00000000-0000-0000-0000-000000000002\",\n          name: \"Cell nucleus\",\n          visible: true,\n        },\n      ]\n    : [\n        {\n          color: \"#AAAAAA\",\n          id: \"00000000-0000-0000-0000-000000000000\",\n          name: \"Unknown\",\n          visible: true,\n        },\n      ];\n\nconst initialState: StateType = {\n  annotated: false,\n  annotating: false,\n  boundingClientRect: new DOMRect(),\n  brightness: 0,\n  categories: initialCategories.length > 0 ? initialCategories : [],\n  channels: [\n    //R, G, and B channels by default\n    {\n      range: [0, 255],\n      visible: true,\n    },\n    {\n      range: [0, 255],\n      visible: true,\n    },\n    {\n      range: [0, 255],\n      visible: true,\n    },\n  ],\n  currentIndex: 0,\n  cursor: \"default\",\n  contrast: 0,\n  exposure: 0,\n  hue: 0,\n  activeImageId: initialImage ? initialImage.id : undefined,\n  images: initialImage ? [initialImage] : [],\n  invertMode: false,\n  language: LanguageType.English,\n  offset: { x: 0, y: 0 },\n  penSelectionBrushSize: 32,\n  pointerSelection: {\n    dragging: false,\n    minimum: undefined,\n    maximum: undefined,\n    selecting: false,\n  },\n  quickSelectionBrushSize: 40,\n  saturation: 0,\n  selectedAnnotation: undefined,\n  selectedAnnotations: [],\n  selectedCategory: \"00000000-0000-0000-0000-000000000000\",\n  selectionMode: AnnotationModeType.New,\n  soundEnabled: true,\n  stageHeight: 1000,\n  stageScale: 1,\n  stageWidth: 1000,\n  stagePosition: { x: 0, y: 0 },\n  toolType: ToolType.RectangularAnnotation,\n  vibrance: 0,\n  zoomSelection: {\n    dragging: false,\n    minimum: undefined,\n    maximum: undefined,\n    selecting: false,\n  },\n};\n\nexport const applicationSlice = createSlice({\n  initialState: initialState,\n  name: \"image-viewer-application\",\n  reducers: {\n    addImages(\n      state: StateType,\n      action: PayloadAction<{ newImages: Array<ImageType> }>\n    ) {\n      //we look for image name duplicates and append number if such duplicates are found\n      const imageNames = state.images.map((image: ImageType) => {\n        return image.name.split(\".\")[0];\n      });\n      const updatedImages = action.payload.newImages.map((image: ImageType) => {\n        const initialName = image.name.split(\".\")[0]; //get name before file extension\n        //add filename extension to updatedName\n        const updatedName =\n          replaceDuplicateName(initialName, imageNames) +\n          \".\" +\n          image.name.split(\".\")[1];\n        return { ...image, name: updatedName };\n      });\n\n      state.images.push(...updatedImages);\n    },\n    clearCategoryAnnotations(\n      state: StateType,\n      action: PayloadAction<{ category: CategoryType }>\n    ) {\n      for (let image of state.images) {\n        image.annotations = image.annotations.filter(\n          (annotation: AnnotationType) => {\n            return annotation.categoryId !== action.payload.category.id;\n          }\n        );\n      }\n    },\n    deleteCategory(\n      state: StateType,\n      action: PayloadAction<{ category: CategoryType }>\n    ) {\n      state.categories = state.categories.filter(\n        (category: CategoryType) => category.id !== action.payload.category.id\n      );\n    },\n    deleteImage(state: StateType, action: PayloadAction<{ id: string }>) {\n      state.images = state.images.filter(\n        (image: ImageType) => image.id !== action.payload.id\n      );\n      if (!state.images.length) state.activeImageId = undefined;\n      else if (\n        state.activeImageId === action.payload.id &&\n        state.images.length\n      ) {\n        state.activeImageId = state.images[0].id;\n      }\n    },\n    deleteAllInstances(\n      state: StateType,\n      action: PayloadAction<{ id: string }>\n    ) {\n      //deletes all instances across all images\n      state.images = state.images.map((image: ImageType) => {\n        return { ...image, annotations: [] };\n      });\n    },\n    deleteAllImageInstances(\n      state: StateType,\n      action: PayloadAction<{ imageId: string }>\n    ) {\n      //deletes all instances across a given image\n      state.images = state.images.map((image: ImageType) => {\n        if (image.id === action.payload.imageId) {\n          return { ...image, annotations: [] };\n        } else return image;\n      });\n    },\n    deleteImageInstances(\n      //deletes given instance on active image\n      state: StateType,\n      action: PayloadAction<{ ids: Array<string> }>\n    ) {\n      if (!state.activeImageId) return;\n\n      state.images = state.images.map((image: ImageType) => {\n        if (image.id === state.activeImageId) {\n          const updatedAnnotations = image.annotations.filter(\n            (annotation: AnnotationType) => {\n              return !action.payload.ids.includes(annotation.id);\n            }\n          );\n          return { ...image, annotations: updatedAnnotations };\n        } else return image;\n      });\n    },\n    openAnnotations(\n      state: StateType,\n      action: PayloadAction<{ file: SerializedFileType }>\n    ) {\n      /*\n       * NOTE: The correct image to annotate is found by looking at the\n       * imageFilename property in the imported annotation file. -- Alice\n       */\n      if (!state.activeImageId) return;\n\n      const annotations = action.payload.file.annotations.map(\n        (annotation: SerializedAnnotationType): AnnotationType => {\n          const { annotation_out, categories } = importSerializedAnnotations(\n            annotation,\n            state.categories\n          );\n          state.categories = categories;\n          return annotation_out;\n        }\n      );\n\n      const loaded: ImageType = {\n        avatar: action.payload.file.imageData,\n        id: action.payload.file.imageId,\n        src: action.payload.file.imageData,\n        originalSrc: action.payload.file.imageData,\n        name: action.payload.file.imageFilename,\n        annotations: annotations,\n        shape: {\n          channels: action.payload.file.imageChannels,\n          frames: action.payload.file.imageFrames,\n          height: action.payload.file.imageHeight,\n          planes: action.payload.file.imagePlanes,\n          width: action.payload.file.imageWidth,\n        },\n      };\n\n      state.images.push(...[loaded]);\n    },\n    setAnnotated(\n      state: StateType,\n      action: PayloadAction<{ annotated: boolean }>\n    ) {\n      state.annotated = action.payload.annotated;\n    },\n    setAnnotating(\n      state: StateType,\n      action: PayloadAction<{ annotating: boolean }>\n    ) {\n      state.annotating = action.payload.annotating;\n    },\n    setBoundingClientRect(\n      state: StateType,\n      action: PayloadAction<{ boundingClientRect: DOMRect }>\n    ) {\n      state.boundingClientRect = action.payload.boundingClientRect;\n    },\n    setBrightness(\n      state: StateType,\n      action: PayloadAction<{ brightness: number }>\n    ) {\n      state.brightness = action.payload.brightness;\n    },\n    setCategories(\n      state: StateType,\n      action: PayloadAction<{ categories: Array<CategoryType> }>\n    ) {\n      state.categories = action.payload.categories;\n    },\n    setCategoryVisibility(\n      state: StateType,\n      action: PayloadAction<{ category: CategoryType; visible: boolean }>\n    ) {\n      const category = _.find(state.categories, (category) => {\n        return category.id === action.payload.category.id;\n      });\n      if (!category) return;\n      category.visible = action.payload.visible;\n      state.categories = [\n        ...state.categories.filter((category) => {\n          return category.id !== action.payload.category.id;\n        }),\n        category,\n      ];\n    },\n    setContrast(state: StateType, action: PayloadAction<{ contrast: number }>) {\n      state.contrast = action.payload.contrast;\n    },\n    setCurrentIndex(\n      state: StateType,\n      action: PayloadAction<{ currentIndex: number }>\n    ) {\n      state.currentIndex = action.payload.currentIndex;\n    },\n    setExposure(state: StateType, action: PayloadAction<{ exposure: number }>) {\n      state.exposure = action.payload.exposure;\n    },\n    setHue(state: StateType, action: PayloadAction<{ hue: number }>) {\n      state.hue = action.payload.hue;\n    },\n    setActiveImage(state: StateType, action: PayloadAction<{ image: string }>) {\n      state.activeImageId = action.payload.image;\n      const activeImage = state.images.find((image: ImageType) => {\n        return image.id === action.payload.image;\n      });\n      if (!activeImage) return;\n      const defaultChannels: Array<ChannelType> = []; //number of channels depends on whether image is greyscale or RGB\n      for (let i = 0; i < activeImage.shape.channels; i++) {\n        defaultChannels.push({\n          range: [0, 255],\n          visible: true,\n        });\n      }\n      state.channels = defaultChannels;\n    },\n    setImageInstances(\n      state: StateType,\n      action: PayloadAction<{ instances: Array<AnnotationType> }>\n    ) {\n      if (!state.activeImageId) return;\n\n      //update corresponding image object in array of Images stored in state\n      state.images = state.images.map((image: ImageType) => {\n        if (state.activeImageId !== image.id) {\n          return image;\n        } else {\n          return { ...image, annotations: action.payload.instances };\n        }\n      });\n    },\n    setImageSrc(state: StateType, action: PayloadAction<{ src: string }>) {\n      if (!state.activeImageId) return;\n      state.images = state.images.map((image: ImageType) => {\n        if (state.activeImageId !== image.id) {\n          return image;\n        } else {\n          return { ...image, src: action.payload.src };\n        }\n      });\n    },\n    setImages(\n      state: StateType,\n      action: PayloadAction<{ images: Array<ImageType> }>\n    ) {\n      state.images = action.payload.images;\n    },\n    setChannels(\n      state: StateType,\n      action: PayloadAction<{\n        channels: Array<ChannelType>;\n      }>\n    ) {\n      state.channels = action.payload.channels;\n    },\n    setCursor(\n      state: StateType,\n      action: PayloadAction<{\n        cursor: string;\n      }>\n    ) {\n      state.cursor = action.payload.cursor;\n    },\n    setInvertMode(\n      state: StateType,\n      action: PayloadAction<{ invertMode: boolean }>\n    ) {\n      state.invertMode = action.payload.invertMode;\n    },\n    setLanguage(\n      state: StateType,\n      action: PayloadAction<{ language: LanguageType }>\n    ) {\n      state.language = action.payload.language;\n    },\n    setOffset(\n      state: StateType,\n      action: PayloadAction<{ offset: { x: number; y: number } }>\n    ) {\n      state.offset = action.payload.offset;\n    },\n    setOperation(\n      state: StateType,\n      action: PayloadAction<{ operation: ToolType }>\n    ) {\n      state.toolType = action.payload.operation;\n    },\n    setPenSelectionBrushSize(\n      state: StateType,\n      action: PayloadAction<{ penSelectionBrushSize: number }>\n    ) {\n      state.penSelectionBrushSize = action.payload.penSelectionBrushSize;\n    },\n    setPointerSelection(\n      state: StateType,\n      action: PayloadAction<{\n        pointerSelection: {\n          dragging: boolean;\n          minimum: { x: number; y: number } | undefined;\n          maximum: { x: number; y: number } | undefined;\n          selecting: boolean;\n        };\n      }>\n    ) {\n      state.pointerSelection = action.payload.pointerSelection;\n    },\n    setQuickSelectionBrushSize(\n      state: StateType,\n      action: PayloadAction<{ quickSelectionBrushSize: number }>\n    ) {\n      state.quickSelectionBrushSize = action.payload.quickSelectionBrushSize;\n    },\n    setSaturation(\n      state: StateType,\n      action: PayloadAction<{ saturation: number }>\n    ) {\n      state.saturation = action.payload.saturation;\n    },\n    setSelectedCategory(\n      state: StateType,\n      action: PayloadAction<{ selectedCategory: string }>\n    ) {\n      state.selectedCategory = action.payload.selectedCategory;\n    },\n    setSelectedAnnotations(\n      state: StateType,\n      action: PayloadAction<{\n        selectedAnnotations: Array<AnnotationType>;\n        selectedAnnotation: AnnotationType | undefined;\n      }>\n    ) {\n      state.selectedAnnotations = action.payload.selectedAnnotations;\n      state.selectedAnnotation = action.payload.selectedAnnotation;\n    },\n    setSelectionMode(\n      state: StateType,\n      action: PayloadAction<{ selectionMode: AnnotationModeType }>\n    ) {\n      state.selectionMode = action.payload.selectionMode;\n    },\n    setStageHeight(\n      state: StateType,\n      action: PayloadAction<{ stageHeight: number }>\n    ) {\n      state.stageHeight = action.payload.stageHeight;\n    },\n    setStagePosition(\n      state: StateType,\n      action: PayloadAction<{ stagePosition: { x: number; y: number } }>\n    ) {\n      state.stagePosition = action.payload.stagePosition;\n    },\n    setStageScale(\n      state: StateType,\n      action: PayloadAction<{ stageScale: number }>\n    ) {\n      state.stageScale = action.payload.stageScale;\n    },\n    setStageWidth(\n      state: StateType,\n      action: PayloadAction<{ stageWidth: number }>\n    ) {\n      state.stageWidth = action.payload.stageWidth;\n    },\n    setSoundEnabled(\n      state: StateType,\n      action: PayloadAction<{ soundEnabled: boolean }>\n    ) {\n      state.soundEnabled = action.payload.soundEnabled;\n    },\n    setVibrance(state: StateType, action: PayloadAction<{ vibrance: number }>) {\n      state.vibrance = action.payload.vibrance;\n    },\n    setZoomSelection(\n      state: StateType,\n      action: PayloadAction<{\n        zoomSelection: {\n          dragging: boolean;\n          minimum: { x: number; y: number } | undefined;\n          maximum: { x: number; y: number } | undefined;\n          selecting: boolean;\n        };\n      }>\n    ) {\n      state.zoomSelection = action.payload.zoomSelection;\n    },\n  },\n  extraReducers: {\n    [\"thunks/loadLayersModel/fulfilled\"]: (\n      state: StateType,\n      action: PayloadAction<tensorflow.LayersModel>\n    ) => {\n      console.info(action.payload);\n    },\n  },\n});\n\nexport const {\n  addImages,\n  deleteCategory,\n  deleteAllInstances,\n  deleteImage,\n  deleteAllImageInstances,\n  setActiveImage,\n  setAnnotating,\n  setAnnotated,\n  setBoundingClientRect,\n  setBrightness,\n  setCategories,\n  setCategoryVisibility,\n  setChannels,\n  setContrast,\n  setCurrentIndex,\n  setCursor,\n  setExposure,\n  setHue,\n  setImageInstances,\n  setImages,\n  setInvertMode,\n  setLanguage,\n  setOffset,\n  setOperation,\n  setPenSelectionBrushSize,\n  setPointerSelection,\n  setQuickSelectionBrushSize,\n  setSaturation,\n  setSelectedAnnotations,\n  setSelectionMode,\n  setSelectedCategory,\n  setSoundEnabled,\n  setStageHeight,\n  setStagePosition,\n  setStageScale,\n  setStageWidth,\n  setVibrance,\n  setZoomSelection,\n} = applicationSlice.actions;\n","import * as _ from \"lodash\";\nimport * as ImageJS from \"image-js\";\nimport { AnnotationType } from \"../types/AnnotationType\";\nimport { decode } from \"./rle\";\nimport { isoLines } from \"marchingsquares\";\nimport { CategoryType } from \"../types/CategoryType\";\nimport { ImageType } from \"../types/ImageType\";\nimport { SerializedAnnotationType } from \"../types/SerializedAnnotationType\";\nimport { saveAs } from \"file-saver\";\n\nexport const connectPoints = (\n  coordinates: Array<Array<number>>,\n  image: ImageJS.Image\n) => {\n  let connectedPoints: Array<Array<number>> = [];\n\n  const foo = _.filter(\n    _.zip(coordinates.slice(0, coordinates.length - 1), coordinates.slice(1)),\n    ([current, next]) => {\n      return !_.isEqual(current, next);\n    }\n  );\n  foo.forEach(([current, next]) => {\n    const points = drawLine(current!, next!);\n    connectedPoints = _.concat(connectedPoints, points);\n  });\n  return connectedPoints;\n};\n\nexport const drawLine = (p: Array<number>, q: Array<number>) => {\n  const coords: Array<Array<number>> = [];\n\n  let x: number,\n    y: number,\n    x1: number,\n    y1: number,\n    x2: number,\n    y2: number,\n    dx: number,\n    dy: number,\n    step: number,\n    i: number;\n\n  x1 = Math.round(p[0]);\n  y1 = Math.round(p[1]);\n  x2 = Math.round(q[0]);\n  y2 = Math.round(q[1]);\n\n  dx = x2 - x1;\n  dy = y2 - y1;\n\n  step = Math.abs(dy);\n\n  if (Math.abs(dx) >= Math.abs(dy)) {\n    step = Math.abs(dx);\n  }\n\n  dx = dx / step;\n  dy = dy / step;\n  x = x1;\n  y = y1;\n  i = 1;\n\n  while (i <= step) {\n    coords.push([Math.round(x), Math.round(y)]);\n    x = x + dx;\n    y = y + dy;\n    i = i + 1;\n  }\n\n  return coords;\n};\n\nexport const getIdx = (width: number, nchannels: number) => {\n  return (x: number, y: number, index: number) => {\n    index = index || 0;\n    return Math.floor((width * y + x) * nchannels + index);\n  };\n};\n\n/*\nGiven a click at a position, return all overlapping annotations ids\n */\nexport const getOverlappingAnnotations = (\n  position: { x: number; y: number },\n  annotations: Array<AnnotationType>,\n  imageWidth: number,\n  imageHeight: number\n) => {\n  const overlappingAnnotations = annotations.filter(\n    (annotation: AnnotationType) => {\n      const boundingBox = annotation.boundingBox;\n      if (\n        position.x >= boundingBox[0] &&\n        position.x <= boundingBox[2] &&\n        position.y >= boundingBox[1] &&\n        position.y <= boundingBox[3]\n      ) {\n        const boundingBoxWidth = boundingBox[2] - boundingBox[0];\n        const boundingBoxHeight = boundingBox[3] - boundingBox[1];\n        if (boundingBoxHeight && boundingBoxWidth) {\n          //return annotation if clicked on actual selected data\n          const maskROI = new ImageJS.Image(\n            boundingBox[2] - boundingBox[0],\n            boundingBox[3] - boundingBox[1],\n            decode(annotation.mask),\n            { components: 1, alpha: 0 }\n          );\n          if (\n            maskROI.getPixelXY(\n              Math.round(position.x - boundingBox[0]),\n              Math.round(position.y - boundingBox[1])\n            )[0]\n          )\n            return annotation;\n        }\n      }\n    }\n  );\n  return overlappingAnnotations.map((annotation: AnnotationType) => {\n    return annotation.id;\n  });\n};\n\nexport const getAnnotationsInBox = (\n  minimum: { x: number; y: number },\n  maximum: { x: number; y: number },\n  annotations: Array<AnnotationType>\n) => {\n  return annotations.filter((annotation: AnnotationType) => {\n    return (\n      minimum.x <= annotation.boundingBox[0] &&\n      minimum.y <= annotation.boundingBox[1] &&\n      maximum.x >= annotation.boundingBox[2] &&\n      maximum.y >= annotation.boundingBox[3]\n    );\n  });\n};\n\nexport const computeContoursFromIsolines = (\n  data: Array<Array<number>>\n): Array<number> => {\n  //pad array to obtain better estimate of contours around mask\n  const pad = 10;\n  const padY = new Array(data[0].length + 2 * pad).fill(0);\n  const padX = new Array(pad).fill(0);\n\n  const paddedMatrix: Array<Array<number>> = [];\n\n  let i;\n  for (i = 0; i < pad; i++) {\n    paddedMatrix.push(padY);\n  }\n  data.forEach((row: Array<number>) => {\n    paddedMatrix.push(padX.concat(row).concat(padX));\n  });\n  for (i = 0; i < pad; i++) {\n    paddedMatrix.push(padY);\n  }\n\n  const largestIsolines = isoLines(paddedMatrix, 1).sort(\n    (a: Array<number>, b: Array<number>) => {\n      return b.length - a.length;\n    }\n  );\n\n  let largestIsoline = largestIsolines[0];\n\n  if (largestIsoline.length <= 5) return [];\n\n  return _.flatten(\n    largestIsoline.map((coord: Array<number>) => {\n      return [Math.round(coord[0] - pad), Math.round(coord[1] - pad)];\n    })\n  );\n};\n\n/*\n * From encoded mask data, get the decoded data and return results as an HTMLImageElement to be used by Konva.Image\n */\nexport const colorOverlayROI = (\n  encodedMask: Array<number>,\n  boundingBox: [number, number, number, number],\n  imageWidth: number,\n  imageHeight: number,\n  color: Array<number>\n): HTMLImageElement | undefined => {\n  if (!encodedMask) return undefined;\n\n  const decodedData = decode(encodedMask);\n\n  const endX = Math.min(imageWidth, boundingBox[2]);\n  const endY = Math.min(imageHeight, boundingBox[3]);\n\n  //extract bounding box params\n  const boxWidth = endX - boundingBox[0];\n  const boxHeight = endY - boundingBox[1];\n\n  if (!boxWidth || !boxHeight) return undefined;\n\n  const croppedImage = new ImageJS.Image(boxWidth, boxHeight, decodedData, {\n    components: 1,\n    alpha: 0,\n  });\n\n  const colorROIImage = new ImageJS.Image(boxWidth, boxHeight, {\n    components: 3,\n    alpha: 1,\n  });\n\n  const checkNeighbors = (\n    arr: ImageJS.Image,\n    x: number,\n    y: number\n  ): boolean => {\n    if (x === 0 || x === boxWidth - 1) return true;\n    for (let [dx, dy] of [\n      [0, 1],\n      [1, 0],\n      [0, -1],\n      [-1, 0],\n    ]) {\n      if (!arr.getPixelXY(x + dx, y + dy)[0]) return true;\n    }\n    return false;\n  };\n\n  for (let i = 0; i < croppedImage.width; i++) {\n    for (let j = 0; j < croppedImage.height; j++) {\n      if (croppedImage.getPixelXY(i, j)[0] > 0) {\n        if (checkNeighbors(croppedImage, i, j)) {\n          colorROIImage.setPixelXY(i, j, [color[0], color[1], color[2], 255]);\n        } else {\n          colorROIImage.setPixelXY(i, j, [color[0], color[1], color[2], 128]);\n        }\n      } else {\n        colorROIImage.setPixelXY(i, j, [0, 0, 0, 0]);\n      }\n    }\n  }\n\n  const src = colorROIImage.toDataURL(\"image-png\", {\n    useCanvas: true,\n  });\n  const image = new Image();\n  image.src = src;\n\n  return image;\n};\n\n/*\n * Method to rename a cateogry/image if a category/image with this name already exists\n * */\nexport const replaceDuplicateName = (name: string, names: Array<string>) => {\n  let currentName = name;\n  let i = 1;\n  while (names.includes(currentName)) {\n    currentName = name + `_${i}`;\n    i += 1;\n  }\n  return currentName;\n};\n\n/*\n * from https://stackoverflow.com/questions/5623838/rgb-to-hex-and-hex-to-rgb\n * */\nconst hexToRgb = (hex: string) => {\n  var result = /^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i.exec(hex);\n  return result\n    ? {\n        r: parseInt(result[1], 16),\n        g: parseInt(result[2], 16),\n        b: parseInt(result[3], 16),\n      }\n    : null;\n};\n\nexport const saveAnnotationsAsBinaryInstanceSegmentationMasks = (\n  images: Array<ImageType>,\n  categories: Array<CategoryType>,\n  zip: any\n): any => {\n  images.forEach((current: ImageType) => {\n    current.annotations.forEach((annotation: AnnotationType) => {\n      const fullLabelImage = new ImageJS.Image(\n        current.shape.width,\n        current.shape.height,\n        new Uint8Array().fill(0),\n        { components: 1, alpha: 0 }\n      );\n      const encoded = annotation.mask;\n      const decoded = decode(encoded);\n      const boundingBox = annotation.boundingBox;\n      const endX = Math.min(current.shape.width, boundingBox[2]);\n      const endY = Math.min(current.shape.height, boundingBox[3]);\n\n      //extract bounding box params\n      const boundingBoxWidth = endX - boundingBox[0];\n      const boundingBoxHeight = endY - boundingBox[1];\n\n      const roiMask = new ImageJS.Image(\n        boundingBoxWidth,\n        boundingBoxHeight,\n        decoded,\n        {\n          components: 1,\n          alpha: 0,\n        }\n      );\n      for (let i = 0; i < boundingBoxWidth; i++) {\n        for (let j = 0; j < boundingBoxHeight; j++) {\n          if (roiMask.getPixelXY(i, j)[0] > 0) {\n            fullLabelImage.setPixelXY(\n              i + annotation.boundingBox[0],\n              j + annotation.boundingBox[1],\n              [255, 255, 255]\n            );\n          }\n        }\n      }\n      const blob = fullLabelImage.toBlob(\"image/png\");\n      const category = categories.find((category: CategoryType) => {\n        return category.id === annotation.categoryId;\n      });\n      if (category) {\n        zip.folder(`${current.name}/${category.name}`);\n        zip.file(\n          `${current.name}/${category.name}/${annotation.id}.png`,\n          blob,\n          {\n            base64: true,\n          }\n        );\n      }\n    });\n  });\n  zip.generateAsync({ type: \"blob\" }).then((blob: Blob) => {\n    saveAs(blob, \"binary_instances.zip\");\n  });\n};\n\nexport const saveAnnotationsAsLabeledSemanticSegmentationMasks = (\n  images: Array<ImageType>,\n  categories: Array<CategoryType>,\n  zip: any\n): any => {\n  images.forEach((current: ImageType) => {\n    const fullLabelImage = new ImageJS.Image(\n      current.shape.width,\n      current.shape.height,\n      new Uint8Array().fill(0),\n      { components: 1, alpha: 0 }\n    );\n    categories.forEach((category: CategoryType) => {\n      const categoryColor = hexToRgb(category.color);\n      if (!categoryColor) return;\n\n      for (let annotation of current.annotations) {\n        if (annotation.categoryId !== category.id) continue;\n        const encoded = annotation.mask;\n        const decoded = decode(encoded);\n        const boundingBox = annotation.boundingBox;\n        const endX = Math.min(current.shape.width, boundingBox[2]);\n        const endY = Math.min(current.shape.height, boundingBox[3]);\n\n        //extract bounding box params\n        const boundingBoxWidth = endX - boundingBox[0];\n        const boundingBoxHeight = endY - boundingBox[1];\n\n        const roiMask = new ImageJS.Image(\n          boundingBoxWidth,\n          boundingBoxHeight,\n          decoded,\n          {\n            components: 1,\n            alpha: 0,\n          }\n        );\n        for (let i = 0; i < boundingBoxWidth; i++) {\n          for (let j = 0; j < boundingBoxHeight; j++) {\n            if (roiMask.getPixelXY(i, j)[0] > 0) {\n              fullLabelImage.setPixelXY(\n                i + annotation.boundingBox[0],\n                j + annotation.boundingBox[1],\n                [categoryColor.r, categoryColor.g, categoryColor.b]\n              );\n            }\n          }\n        }\n      }\n    });\n    const blob = fullLabelImage.toBlob(\"image/png\");\n    zip.file(`${current.name}.png`, blob, {\n      base64: true,\n    });\n  });\n  zip.generateAsync({ type: \"blob\" }).then((blob: Blob) => {\n    saveAs(blob, \"labeled_semantic.zip\");\n  });\n};\n\nexport const saveAnnotationsAsLabelMatrix = (\n  images: Array<ImageType>,\n  categories: Array<CategoryType>,\n  zip: any,\n  random: boolean = false,\n  binary: boolean = false\n): Array<Promise<unknown>> => {\n  return images\n    .map((current: ImageType) => {\n      return categories.map((category: CategoryType) => {\n        return new Promise((resolve, reject) => {\n          const fullLabelImage = new ImageJS.Image(\n            current.shape.width,\n            current.shape.height,\n            new Uint8Array().fill(0),\n            { components: 1, alpha: 0 }\n          );\n          let r = binary ? 255 : 1;\n          let g = binary ? 255 : 1;\n          let b = binary ? 255 : 1;\n          for (let annotation of current.annotations) {\n            if (random) {\n              r = Math.round(Math.random() * 255);\n              g = Math.round(Math.random() * 255);\n              b = Math.round(Math.random() * 255);\n            } else if (!binary) {\n              r = r + 1;\n              b = b + 1;\n              g = g + 1;\n            }\n            if (annotation.categoryId !== category.id) continue;\n            const encoded = annotation.mask;\n            const decoded = decode(encoded);\n            const boundingBox = annotation.boundingBox;\n            const endX = Math.min(current.shape.width, boundingBox[2]);\n            const endY = Math.min(current.shape.height, boundingBox[3]);\n\n            //extract bounding box params\n            const boundingBoxWidth = endX - boundingBox[0];\n            const boundingBoxHeight = endY - boundingBox[1];\n\n            const roiMask = new ImageJS.Image(\n              boundingBoxWidth,\n              boundingBoxHeight,\n              decoded,\n              {\n                components: 1,\n                alpha: 0,\n              }\n            );\n            for (let i = 0; i < boundingBoxWidth; i++) {\n              for (let j = 0; j < boundingBoxHeight; j++) {\n                if (roiMask.getPixelXY(i, j)[0] > 0) {\n                  fullLabelImage.setPixelXY(\n                    i + annotation.boundingBox[0],\n                    j + annotation.boundingBox[1],\n                    [r, g, b]\n                  );\n                }\n              }\n            }\n          }\n          const blob = fullLabelImage.toBlob(\"image/png\");\n          zip.folder(`${current.name}`);\n          zip.file(`${current.name}/${category.name}.png`, blob, {\n            base64: true,\n          });\n          resolve(true);\n        });\n      });\n    })\n    .flat();\n};\n\nexport const importSerializedAnnotations = (\n  annotation: SerializedAnnotationType,\n  existingCategories: Array<CategoryType>\n): { annotation_out: AnnotationType; categories: Array<CategoryType> } => {\n  const mask = annotation.annotationMask\n    .split(\" \")\n    .map((x: string) => parseInt(x));\n\n  let newCategories = existingCategories;\n  //if category does not already exist in state, add it\n  if (\n    !existingCategories\n      .map((category: CategoryType) => category.id)\n      .includes(annotation.annotationCategoryId)\n  ) {\n    const category: CategoryType = {\n      color: annotation.annotationCategoryColor,\n      id: annotation.annotationCategoryId,\n      name: annotation.annotationCategoryName,\n      visible: true,\n    };\n    newCategories = [...newCategories, category];\n  }\n\n  return {\n    annotation_out: {\n      boundingBox: [\n        annotation.annotationBoundingBoxX,\n        annotation.annotationBoundingBoxY,\n        annotation.annotationBoundingBoxWidth,\n        annotation.annotationBoundingBoxHeight,\n      ],\n      categoryId: annotation.annotationCategoryId,\n      id: annotation.annotationId,\n      mask: mask,\n    },\n    categories: newCategories,\n  };\n};\n","import { createSlice, PayloadAction } from \"@reduxjs/toolkit\";\nimport { ToolOptionsStateType } from \"../../types/ToolOptionsStateType\";\nimport { ZoomModeType } from \"../../types/ZoomModeType\";\nimport { ZoomToolOptionsType } from \"../../types/ZoomToolOptionsType\";\nimport { ColorAdjustmentOptionsType } from \"../../types/ColorAdjustmentOptionsType\";\n\nconst initialState: ToolOptionsStateType = {\n  colorAdjustment: {\n    blackPoint: 0,\n    brightness: 0,\n    contrast: 0,\n    exposure: 0,\n    highlights: 0,\n    hue: 0,\n    saturation: 0,\n    shadows: 0,\n    vibrance: 0,\n  },\n  zoom: {\n    automaticCentering: true,\n    mode: ZoomModeType.In,\n    scale: 1.0,\n    toActualSize: false,\n    toFit: false,\n  },\n};\n\nexport const toolOptionsSlice = createSlice({\n  initialState: initialState,\n  name: \"image-viewer-tool-options\",\n  reducers: {\n    setColorAdjustmentOptions(\n      state: ToolOptionsStateType,\n      action: PayloadAction<{ options: ColorAdjustmentOptionsType }>\n    ) {\n      state.colorAdjustment = action.payload.options;\n    },\n    setZoomToolOptions(\n      state: ToolOptionsStateType,\n      action: PayloadAction<{ options: ZoomToolOptionsType }>\n    ) {\n      state.zoom = action.payload.options;\n    },\n  },\n});\n\nexport const { setZoomToolOptions } = toolOptionsSlice.actions;\n","export enum ZoomModeType {\n  In,\n  Out,\n}\n","import { combineReducers } from \"redux\";\nimport { applicationSlice } from \"../slices\";\nimport { toolOptionsSlice } from \"../slices/toolOptionsSlice\";\nimport undoable, { groupByActionTypes } from \"redux-undo\";\nimport { StateType } from \"../../types/StateType\";\nimport { HistoryStateType } from \"../../types/HistoryStateType\";\nimport * as _ from \"lodash\";\n\nconst filterActions = (\n  action: any,\n  currentState: StateType,\n  previousHistory: HistoryStateType\n) => {\n  const actions = [\n    \"image-viewer-application/setImageInstances\",\n    \"image-viewer-application/setAnnotated\",\n    \"image-viewer-application/setAnnotating\",\n    \"image-viewer-application/deleteImageInstance\",\n    \"image-viewer-application/setSelectedAnnotation\",\n    \"image-viewer-application/setSelectedAnnotationId\",\n  ];\n  return _.includes(actions, action.type);\n};\n\nconst reducers = {\n  state: undoable(applicationSlice.reducer, {\n    filter: filterActions,\n    groupBy: groupByActionTypes(\"image-viewer-application/deleteImageInstance\"),\n  }),\n  toolOptions: toolOptionsSlice.reducer,\n};\n\nexport const reducer = combineReducers(reducers);\n","import {\n  configureStore,\n  EnhancedStore,\n  Middleware,\n  StoreEnhancer,\n} from \"@reduxjs/toolkit\";\nimport logger from \"redux-logger\";\nimport { reducer } from \"../reducer\";\nimport * as Sentry from \"@sentry/react\";\nimport thunk from \"redux-thunk\";\n\nconst sentryReduxEnhancer = Sentry.createReduxEnhancer({});\n\nconst enhancers: StoreEnhancer[] = [sentryReduxEnhancer];\n\nconst middleware: Middleware[] = [logger, thunk];\n\nconst preloadedState = {};\n\nconst options = {\n  devTools: true,\n  enhancers: enhancers,\n  middleware: middleware,\n  preloadedState: preloadedState,\n  reducer: reducer,\n};\n\nexport const store: EnhancedStore = configureStore(options);\n","import { createAsyncThunk } from \"@reduxjs/toolkit\";\n\nconst echo = async (message: string): Promise<string> => {\n  return message;\n};\n\nexport const echoThunk = createAsyncThunk(\n  \"thunks/echo\",\n  async (message: string) => {\n    return await echo(message);\n  }\n);\n","import { createAsyncThunk } from \"@reduxjs/toolkit\";\nimport * as tensorflow from \"@tensorflow/tfjs\";\n\nexport const loadLayersModelThunk = createAsyncThunk(\n  \"thunks/loadLayersModel\",\n  async ({ name, path }: { name: string; path: string }) => {\n    return await tensorflow.loadLayersModel(path);\n  }\n);\n","import i18n, { InitOptions } from \"i18next\";\nimport { initReactI18next } from \"react-i18next\";\nimport { de, en, fi, hi, hu, se, gr } from \"./translations\";\n\nconst resources = {\n  de: de,\n  en: en,\n  fi: fi,\n  hi: hi,\n  hu: hu,\n  se: se,\n  gr: gr,\n};\n\nconst options: InitOptions = {\n  resources,\n  interpolation: { escapeValue: false },\n  keySeparator: false,\n  lng: \"en\",\n};\n\ni18n\n  .use(initReactI18next)\n  .init(options)\n  .then(() => {});\n\nexport default i18n;\n","// prettier-ignore\nimport {language} from \"./language\";\n\nconst de: language = {\n  translation: {\n    Cancel: \"Abbrechen\",\n    Categories: \"Kategorien\",\n    \"Create category\": \"Neue Kategorie\",\n    \"Create new classifier\": \"Neuer Classifier\",\n    \"Delete category\": \"Lösche Kategorie\",\n    \"Delete images\": \"Lösche Bilder\",\n    Description: \"Beschreibung\",\n    Edit: \"Edit\",\n    \"Edit category\": \"Bearbeite Kategorie\",\n    Help: \"Hilfe\",\n    \"Hide other categories\": \"Blende andere Kategorien aus\",\n    \"Hide sidebar\": \"Blende Sidebar aus\",\n    \"Import images\": \"Bilder hinzufügen\",\n    Logo: \"Logo\",\n    Model: \"Modell\",\n    \"Open classifier\": \"Öffne Classifier\",\n    \"Open example classifier\": \"Öffne Beispiel Classifier\",\n    \"Open weights\": \"Öffne Gewichte\",\n    Open: \"Öffnen\",\n    \"Run classifier\": \"Starte Classfier\",\n    \"Save annotations and predictions\": \"Speicher Labels und Predictions\",\n    \"Save classifier\": \"Speicher Classifier\",\n    \"Save weights\": \"Speicher Gewichte\",\n    Save: \"Speichern\",\n    \"Search images\": \"Durchsuche Bilder\",\n    \"Send feedback\": \"Sende Feedback\",\n    Settings: \"Einstellungen\",\n    \"Show sidebar\": \"Blende Sidebar ein\",\n    Unknown: \"Unbekannt\",\n  },\n};\n\nexport default de;\n","import { language } from \"./language\";\n\nconst en: language = {\n  translation: {\n    Cancel: \"Cancel\",\n    Categories: \"Categories\",\n    \"Create category\": \"Create category\",\n    \"Create new classifier\": \"Create new classifier\",\n    \"Delete category\": \"Delete category\",\n    \"Delete images\": \"Delete images\",\n    Description: \"Description\",\n    Edit: \"Edit\",\n    \"Edit category\": \"Edit category\",\n    Help: \"Help\",\n    \"Hide other categories\": \"Hide other categories\",\n    \"Hide sidebar\": \"Hide sidebar\",\n    \"Import images\": \"Import images\",\n    Logo: \"Logo\",\n    Model: \"Model\",\n    \"Open classifier\": \"Open classifier\",\n    \"Open example classifier\": \"Open example classifier\",\n    \"Open weights\": \"Open weights\",\n    Open: \"Open\",\n    \"Run classifier\": \"Run classifier\",\n    \"Save annotations and predictions\": \"Save annotations and predictions\",\n    \"Save classifier\": \"Save classifier\",\n    \"Save weights\": \"Save weights\",\n    Save: \"Save\",\n    \"Search images\": \"Search images\",\n    \"Send feedback\": \"Send feedback\",\n    Settings: \"Settings\",\n    \"Show sidebar\": \"Show sidebar\",\n    Unknown: \"Unknown\",\n  },\n};\n\nexport default en;\n","// prettier-ignore\nimport {language} from \"./language\";\n\nconst fi: language = {\n  translation: {\n    Cancel: \"Peruuta\",\n    Categories: \"Kategoriat\",\n    \"Create category\": \"Luo kategoria\",\n    \"Create new classifier\": \"Luo uusi luokittelija\",\n    \"Delete category\": \"Poista kategoria\",\n    \"Delete images\": \"Poista kuvat\",\n    Description: \"Kuvaus\",\n    Edit: \"Edit\",\n    \"Edit category\": \"Muokkaa kategoriaa\",\n    Help: \"Apua\",\n    \"Hide other categories\": \"Piilota muut kategoriat\",\n    \"Hide sidebar\": \"Piilota sivupalkki\",\n    \"Import images\": \"Tuo kuvat\",\n    Logo: \"Logo\",\n    Model: \"Malli\",\n    \"Open classifier\": \"Avaa luokittelija\",\n    \"Open example classifier\": \"Avaa esimerkkiluokittelija\",\n    \"Open weights\": \"Avaa painot\",\n    Open: \"Avaa\",\n    \"Run classifier\": \"Suorita luokittelija\",\n    \"Save annotations and predictions\":\n      \"Tallenna annotaatiot ja luokittelun tulos\",\n    \"Save classifier\": \"Tallenna luokittelija\",\n    \"Save weights\": \"Tallenna painot\",\n    Save: \"Tallenna\",\n    \"Search images\": \"Etsi kuvia\",\n    \"Send feedback\": \"Lähetä palautetta\",\n    Settings: \"Asetukset\",\n    \"Show sidebar\": \"Näytä sivupalkki\",\n    Unknown: \"Tuntematon\",\n  },\n};\n\nexport default fi;\n","// prettier-ignore\nimport {language} from \"./language\";\n\nconst hi: language = {\n  translation: {\n    Cancel: \"रद्द करें\",\n    Categories: \"सारे वर्ग\",\n    \"Create category\": \"वर्ग बनाएँ\",\n    \"Create new classifier\": \"नया वर्गीकर्त्ता बनाएं\", // वर्गीकर्त्ता = classifier but is rarely used; consider transliterating instead\n    \"Delete category\": \"वर्ग हटाएँ\",\n    \"Delete images\": \"चित्रों को हटाएँ\",\n    Description: \"विवरण\",\n    \"Edit category\": \"वर्ग का बदलाव करें\",\n    Help: \"सहायता\",\n    \"Hide other categories\": \"बाकि वर्गों को छिपाएं\",\n    \"Hide sidebar\": \"साइडबार छिपाएं\",\n    \"Import images\": \"चित्रों को आयात करें\",\n    Logo: \"लोगो\", // transliterated (Logo) but that's ok because it is a loanword\n    Model: \"मॉडल\", // transliterated (Model) but should figure out an appropriate abstraction and translate that\n    \"Open classifier\": \"वर्गीकर्त्ता खोलें\",\n    \"Open example classifier\": \"उदाहरण का वर्गीकर्त्ता खोलें\",\n    \"Open weights\": \"वेइट्स खोलें\",\n    Open: \"खोलें\",\n    \"Run classifier\": \"वर्गीकर्त्ता को चलाएं\",\n    \"Save annotations and predictions\": \"टिप्पणी तथा अनुमान सहेजें\", // व्याख्या is an alternative to टिप्पणी\n    \"Save classifier\": \"वर्गीकर्त्ता सहेजें\",\n    \"Save weights\": \"वेइट्स सहेजें\",\n    Save: \"सहेजें\",\n    \"Search images\": \"चित्र खोजें\",\n    \"Send feedback\": \"प्रतिक्रिया भेजें\",\n    Settings: \"सेटिंग्स\",\n    \"Show sidebar\": \"साइडबार दिखाएं\",\n    Unknown: \"अज्ञात\", // should be used as an adjective before a noun\n  },\n};\n\nexport default hi;\n","// prettier-ignore\nimport {language} from \"./language\";\n\nconst hu: language = {\n  translation: {\n    Cancel: \"Mégse\",\n    Categories: \"Osztályok\",\n    \"Create category\": \"Új osztály létrehozása\",\n    \"Create new classifier\": \"Új osztályozó létrehozása\",\n    \"Delete category\": \"Osztály törlése\",\n    \"Delete images\": \"Képek törlése\",\n    Description: \"Leírás\",\n    Edit: \"Edit\",\n    \"Edit category\": \"Kategória szerkesztése\",\n    Help: \"Súgó\",\n    \"Hide other categories\": \"Többi osztály elrejtése\",\n    \"Hide sidebar\": \"Oldalsáv elrejtése\",\n    \"Import images\": \"Képek importálása\",\n    Logo: \"Logó\",\n    Model: \"Modell\",\n    \"Open classifier\": \"Osztályozó betöltése\",\n    \"Open example classifier\": \"Példa osztályozó betöltése\",\n    \"Open weights\": \"Súlyok betöltése\",\n    Open: \"Megnyitás\",\n    \"Run classifier\": \"Osztályozó futtatása\",\n    \"Save annotations and predictions\": \"Címkék és predikciók mentése\",\n    \"Save classifier\": \"Osztályozó mentése\",\n    \"Save weights\": \"Súlyok mentése\",\n    Save: \"Mentés\",\n    \"Search images\": \"Képek keresése\",\n    \"Send feedback\": \"Visszajelzés küldése\",\n    Settings: \"Beállítások\",\n    \"Show sidebar\": \"Oldalsáv megjelenítése\",\n    Unknown: \"Ismeretlen\",\n  },\n};\n\nexport default hu;\n","// prettier-ignore\nimport {language} from \"./language\";\n\nconst se: language = {\n  translation: {\n    Cancel: \"Annullera\",\n    Categories: \"kategorier\",\n    \"Create category\": \"Skapa kategori\",\n    \"Create new classifier\": \"Skapa ny klassificerare\",\n    \"Delete category\": \"Ta bort kategori\",\n    \"Delete images\": \"Ta bort bilder\",\n    Description: \"Beskrivning\",\n    Edit: \"Edit\",\n    \"Edit category\": \"Redigera kategori\",\n    Help: \"Hjälp\",\n    \"Hide other categories\": \"gömma andra kategorier\",\n    \"Hide sidebar\": \"Dölj sidfältet\",\n    \"Import images\": \"Importera bilder\",\n    Logo: \"Logo\",\n    Model: \"Modell\",\n    \"Open classifier\": \"Öppna klassificerare\",\n    \"Open example classifier\": \"Öppna exempel klassificeraren\",\n    \"Open weights\": \"Öppna vikter\",\n    Open: \"Öppna\",\n    \"Run classifier\": \"Kör klassificeringsenheten\",\n    \"Save annotations and predictions\": \"Spara kommentarer och förutsägelser\",\n    \"Save classifier\": \"Spara klassificerare\",\n    \"Save weights\": \"Spara vikter\",\n    Save: \"Spara\",\n    \"Search images\": \"Sök bilder\",\n    \"Send feedback\": \"Skicka feedback\",\n    Settings: \"Inställningar\",\n    \"Show sidebar\": \"Visa sidofältet\",\n    Unknown: \"Okänd\",\n  },\n};\n\nexport default se;\n","// prettier-ignore\nimport {language} from \"./language\";\n\nconst gr: language = {\n  translation: {\n    Cancel: \"Άκυρο\",\n    Categories: \"Κατηγορίες\",\n    \"Create category\": \"Δημιουργία κατηγορίας\",\n    \"Create new classifier\": \"Νέος ταξινομητής\",\n    \"Delete category\": \"Διαγραφή κατηγορίας\",\n    \"Delete images\": \"Διαγραφή εικόνων\",\n    Description: \"Περιγραφή\",\n    Edit: \"Επεξεργασία\",\n    \"Edit category\": \"Επεξεργασία κατηγορίας\",\n    Help: \"Βοήθεια\",\n    \"Hide other categories\": \"Απόκρυψη άλλων κατηγοριών\",\n    \"Hide sidebar\": \"Απόκρυψη πλευρικής γραμμής\",\n    \"Import images\": \"Εισαγωγή εικόνων\",\n    Logo: \"Λογότυπο\",\n    Model: \"Mοντέλο\",\n    \"Open classifier\": \"Άνοιγμα ταξινομητή\",\n    \"Open example classifier\": \"Παράδειγμα ταξινομητή\",\n    \"Open weights\": \"Άνοιγμα παραμέτρων\",\n    Open: \"Άνοιγμα\",\n    \"Run classifier\": \"Εκτέλεση ταξινομητή\",\n    \"Save annotations and predictions\": \"Αποθήκευση ετικετών και προβλέψεων\",\n    \"Save classifier\": \"Αποθήκευση ταξινομητή\",\n    \"Save weights\": \"Αποθήκευση παραμέτρων\",\n    Save: \"Αποθήκευση\",\n    \"Search images\": \"Αναζήτηση εικόνων\",\n    \"Send feedback\": \"Eπικοινωνια\",\n    Settings: \"Ρυθμίσεις\",\n    \"Show sidebar\": \"Εμφάνιση πλευρικής γραμμής\",\n    Unknown: \"Άγνωστο\",\n  },\n};\n\nexport default gr;\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport reportWebVitals from \"./reportWebVitals\";\nimport { ImageViewer } from \"./components\";\nimport { Provider } from \"react-redux\";\nimport { store } from \"./store\";\nimport * as Sentry from \"@sentry/react\";\nimport \"./i18n\";\nimport { DndProvider } from \"react-dnd\";\nimport { HTML5Backend } from \"react-dnd-html5-backend\";\n\nSentry.init({\n  dsn: \"https://756e21ab7263457eab9bc2f65edddc79@o71028.ingest.sentry.io/5668724\",\n  release: \"annotator@\" + process.env.npm_package_version,\n});\n\nconst Redirect = () => {\n  const newLocation = \"https://www.piximi.app/annotator\";\n\n  return (\n    <p>\n      This standalone annotator prototype is now part of the broader Piximi\n      application. If automatic redirection fails, visit{\" \"}\n      <a href={newLocation}>piximi.app/annotator</a>.\n    </p>\n  );\n};\n\nReactDOM.render(\n  <React.StrictMode>\n    <Redirect />\n    <Provider store={store}>\n      <DndProvider backend={HTML5Backend}>{/* <ImageViewer /> */}</DndProvider>\n    </Provider>\n  </React.StrictMode>,\n  document.getElementById(\"root\")\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}